{"ast":null,"code":"import { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nvar _jsxFileName = \"/Users/gimminseong/side_project/apple_farm/pratice/apple-farm/src/pages/signup.js\";\nimport React, { useCallback, useState } from 'react';\nimport Head from 'next/head';\nimport { Form } from 'antd';\nimport AppLayouts from '../components/AppLayouts'; // useCallback  : useMemo와 비슷한 훅임안된다 (퍼포먼스 최적화를 위해서 사용되는 훅이다)\n// 리액트 개발자 도구 > Profiler 탭의 Start Profiling기능(녹화 버튼)을 사용하면 컴포넌트의 랜더링을 분석할 수 있다.\n// https://thisblogfor.me/react/hooks_memoization/\n// useMemo는 특정 결과값을 재사용 할 때 사용하는 반면\n// useCallback은 특정 함수를 새로 만들지 않고 재사용 하고 싶을 때 사용함\n// 렌더링 될 대 함수도 다시 생성하는데 그것을 막기 위함.\n// useState : 컴포넌트에서 바뀌는 값 관리하기. 컴포넌트에서 상태를 관리할 수 있음!!\n//  16.8 버전에서는 함수형 컴포넌트에서는 상태를 관리할 수 없었다. 하지만 hooks라는 기능을 통해 컴포넌트에서도 상태를 관리할 수 있게 되었음\n// 컴포넌트에서는 동적인 값을 상태라고 부른다. 리액트에서 useState라는 함수가 있는데 이것을 사용하면 컴포넌트에서 상태 관리 가능함\n\nconst Signup = () => {\n  // 훅스들의 세트를 묶을 수 있다.\n  // 반복되는것들을 커스텀 훅을 통해 묶을 수 있다.\n  // 컴포넌트 로직 자체를 분할하거나 재사용할 수 있음.\n  const {\n    0: id,\n    1: setId\n  } = useState('');\n  const onChangeId = useCallback(e => {\n    setId(e.target.value);\n  }, []);\n  const {\n    0: pw,\n    1: setPw\n  } = useState('');\n  const onChangePassword = useCallback(e => {\n    setPassword(e.target.value);\n  }, []);\n\n  function onSubmit() {}\n\n  return /*#__PURE__*/_jsxDEV(AppLayouts, {\n    children: [/*#__PURE__*/_jsxDEV(Head, {\n      children: /*#__PURE__*/_jsxDEV(\"title\", {\n        children: \"\\uD68C\\uC6D0\\uAC00\\uC785 | NodeBird\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 46,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 45,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(Form, {\n      onFinsh: onSubmit,\n      children: /*#__PURE__*/_jsxDEV(\"div\", {\n        children: /*#__PURE__*/_jsxDEV(\"label\", {}, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 51,\n          columnNumber: 11\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 50,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 48,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 43,\n    columnNumber: 5\n  }, this);\n};\n\nexport default Signup;","map":{"version":3,"sources":["/Users/gimminseong/side_project/apple_farm/pratice/apple-farm/src/pages/signup.js"],"names":["React","useCallback","useState","Head","Form","AppLayouts","Signup","id","setId","onChangeId","e","target","value","pw","setPw","onChangePassword","setPassword","onSubmit"],"mappings":";;AAAA,OAAOA,KAAP,IAAeC,WAAf,EAA4BC,QAA5B,QAA2C,OAA3C;AACA,OAAOC,IAAP,MAAiB,WAAjB;AACA,SAAQC,IAAR,QAAmB,MAAnB;AACA,OAAOC,UAAP,MAAuB,0BAAvB,C,CAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;;AAKA,MAAMC,MAAM,GAAG,MAAQ;AACrB;AACA;AACA;AACA,QAAM;AAAA,OAACC,EAAD;AAAA,OAAKC;AAAL,MAAcN,QAAQ,CAAC,EAAD,CAA5B;AACA,QAAMO,UAAU,GAAGR,WAAW,CAAES,CAAD,IAAO;AACpCF,IAAAA,KAAK,CAACE,CAAC,CAACC,MAAF,CAASC,KAAV,CAAL;AACD,GAF6B,EAE3B,EAF2B,CAA9B;AAKA,QAAM;AAAA,OAACC,EAAD;AAAA,OAAKC;AAAL,MAAcZ,QAAQ,CAAC,EAAD,CAA5B;AACA,QAAMa,gBAAgB,GAAGd,WAAW,CAAES,CAAD,IAAO;AAC1CM,IAAAA,WAAW,CAACN,CAAC,CAACC,MAAF,CAASC,KAAV,CAAX;AACD,GAFmC,EAEjC,EAFiC,CAApC;;AAIA,WAASK,QAAT,GAAoB,CAEnB;;AACD,sBAEE,QAAC,UAAD;AAAA,4BAEE,QAAC,IAAD;AAAA,6BACE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADF;AAAA;AAAA;AAAA;AAAA,YAFF,eAKE,QAAC,IAAD;AAAM,MAAA,OAAO,EAAEA,QAAf;AAAA,6BAEE;AAAA,+BACE;AAAA;AAAA;AAAA;AAAA;AADF;AAAA;AAAA;AAAA;AAAA;AAFF;AAAA;AAAA;AAAA;AAAA,YALF;AAAA;AAAA;AAAA;AAAA;AAAA,UAFF;AAqBD,CAvCD;;AA0CA,eAAeX,MAAf","sourcesContent":["import React, {useCallback, useState} from 'react';\nimport Head from 'next/head';\nimport {Form} from 'antd';\nimport AppLayouts from '../components/AppLayouts';\n\n// useCallback  : useMemo와 비슷한 훅임안된다 (퍼포먼스 최적화를 위해서 사용되는 훅이다)\n// 리액트 개발자 도구 > Profiler 탭의 Start Profiling기능(녹화 버튼)을 사용하면 컴포넌트의 랜더링을 분석할 수 있다.\n// https://thisblogfor.me/react/hooks_memoization/\n\n// useMemo는 특정 결과값을 재사용 할 때 사용하는 반면\n// useCallback은 특정 함수를 새로 만들지 않고 재사용 하고 싶을 때 사용함\n\n// 렌더링 될 대 함수도 다시 생성하는데 그것을 막기 위함.\n\n// useState : 컴포넌트에서 바뀌는 값 관리하기. 컴포넌트에서 상태를 관리할 수 있음!!\n//  16.8 버전에서는 함수형 컴포넌트에서는 상태를 관리할 수 없었다. 하지만 hooks라는 기능을 통해 컴포넌트에서도 상태를 관리할 수 있게 되었음\n\n// 컴포넌트에서는 동적인 값을 상태라고 부른다. 리액트에서 useState라는 함수가 있는데 이것을 사용하면 컴포넌트에서 상태 관리 가능함\n\n\n\n\nconst Signup = () =>   {\n  // 훅스들의 세트를 묶을 수 있다.\n  // 반복되는것들을 커스텀 훅을 통해 묶을 수 있다.\n  // 컴포넌트 로직 자체를 분할하거나 재사용할 수 있음.\n  const [id, setId] = useState('');\n  const onChangeId = useCallback((e) => {\n    setId(e.target.value);\n  }, []);\n\n\n  const [pw, setPw] = useState('');\n  const onChangePassword = useCallback((e) => {\n    setPassword(e.target.value);\n  }, []);\n\n  function onSubmit() {\n\n  }\n  return (\n\n    <AppLayouts>\n\n      <Head>\n        <title>회원가입 | NodeBird</title>\n      </Head>\n      <Form onFinsh={onSubmit}>\n\n        <div>\n          <label>\n\n          </label>\n        </div>\n\n      </Form>\n\n\n    </AppLayouts>\n  );\n\n};\n\n\nexport default Signup;"]},"metadata":{},"sourceType":"module"}